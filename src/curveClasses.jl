"""
Build the second homology of the GKM graph.
Note that the returned ans.H2 is by definition the quotient of the Z-module generated by the edges
modulo the relations in second integral homology. Thus, ans.H2 is the submodule of second integral homology
generated by classes of T-invariant curves.
"""
function GKM_second_homology(G::AbstractGKM_graph)::GKM_H2

  nEdges = n_edges(G.g)
  edgeList = Vector{Edge}()
  sizehint!(edgeList, nEdges)
  for e in edges(G.g)
    push!(edgeList, e)
  end

  edgeToGenIndex = Dict{Edge, Int64}()
  for i in 1:length(edgeList)
    e = edgeList[i]
    edgeToGenIndex[e] = i
    edgeToGenIndex[reverse(e)] = i
  end

  r = rank_torus(G)
  M = free_module(ZZ, nEdges)

  cycles = _calculate_graph_cycles(G, edgeList, M)
  relations = Vector{AbstractAlgebra.Generic.FreeModuleElem{ZZRingElem}}()
  sizehint!(relations, r * length(cycles))
  
  for c in cycles
    for i in 1:r
      rel = zero(M)
      for (e,mult) in c
        edgeIndex = indexin([e], edgeList)[1]
        rel += mult * G.w[e][i] * gens(M)[edgeIndex]
      end
      push!(relations, rel)
    end
  end

  R, _ = sub(M, relations)
  H2withTorsion, q1 = quo(M, R)
  H2, q2 = _remove_torsion(H2withTorsion)

  edgeLattice = M
  quotientMap = compose(q1, q2)

  return GKM_H2(G, edgeLattice, H2, edgeToGenIndex, quotientMap)
end

"""
Return a basis of the first homology of graph underlying the GKM graph.
"""
function _calculate_graph_cycles(G::AbstractGKM_graph, edgeList::Vector{Edge}, M::AbstractAlgebra.Generic.FreeModule{ZZRingElem})::Vector{Vector{Tuple{Edge, ZZRingElem}}}

  nVertices = n_vertices(G.g)
  nEdges = n_edges(G.g)

  C0 = free_module(ZZ, nVertices)
  C1 = M

  dVals = Vector{AbstractAlgebra.Generic.FreeModuleElem{ZZRingElem}}()
  sizehint!(dVals, nEdges)

  for e in edgeList
    de = gens(C0)[src(e)] - gens(C0)[dst(e)]
    push!(dVals, de)
  end
  
  d = ModuleHomomorphism(C1, C0, dVals)
  K, k = kernel(d)

  cycles = Vector{Vector{Tuple{Edge, ZZRingElem}}}()
  for cyc in gens(K)
    cycEdges = Vector{Tuple{Edge, ZZRingElem}}()
    cycIm = k(cyc)
    for i in 1:nEdges
      push!(cycEdges, (edgeList[i], cycIm[i]))
    end
    push!(cycles, cycEdges)
  end

  return cycles
end

function _remove_torsion(M::AbstractAlgebra.FPModule{ZZRingElem})

  normalForm, s = snf(M)
  invariantFactors = normalForm.invariant_factors
  torsionGenerators = Vector{}()

  for i in 1:length(invariantFactors)
    if invariantFactors[i] != 0
      push!(torsionGenerators, s(gens(normalForm)[i]))
    end
  end

  torsionSub, _ = sub(M, torsionGenerators)

  return quo(M, torsionSub)
end

function Base.show(io::IO, h2::GKM_H2)

  if Oscar.is_terse(io)
    # no nested printing
    print(io, "GKM curve classes in H_2")
  else
    # nested printing allowed, preferably terse
    print(io, "GKM curve classes in H_2 for $(h2.gkm)")
  end
end

# detailed show
function Base.show(io::IO, ::MIME"text/plain",  h2::GKM_H2)
  print(io, "Curve classes in H_2 for $(h2.gkm): $(h2.H2)")
end

# TODO (Daniel): iterate over multiplicities for given beta and given edges.